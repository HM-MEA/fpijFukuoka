# １章　Hello、ラムダ式

## 1.1 考え方を変える
従来型のコードは命令型で手続き的にプログラムを記述する。<br>
より良い方法として、宣言型での記述を。<br>

コレクションに特定の値が含まれているか調べる際に、コレクションの要素を特定の値が見つかるまでイテレートするのは命令型。<br>
コレクションの要素が含まれているかどうかのAPIを使えば宣言型。

ラムダ式の登場前は命令型でしか書けなかった処理も、ラムダ式の登場で宣言型に記述できるようになった。

例）
```
final BigDecimal totalOf値引価格 =
 prices.stream()
       .filter(価格 -> 価格.compareTo(BigDecimal.valueOf(20)) > 0)
       .map(価格 -> 価格.multiply(BigDecimal.valueOf(0.9)))
       .reduce(BigDecimal.ZERO, BigDecimal::add);
System.out.println("値引き後価格の合計: " + totalOf値引価格);
```

こうすることによる改善ポイントまとめ
* mutableな変数を扱わずにすむ
* イテレーションのステップが隠蔽される（ライブラリによるイテレーション制御）
* コードがビジネス要件に沿っており、邪魔が少ない
* エラー発生の可能性が少ない
* 低レベルの操作から解放される
* 機能強化やロジック変更がより簡単
* ループの遅延評価によりもたらされる効率の良さ
* 必要な場合、簡単に並列化が可能

## 1.2 関数型のコードによる大きな利益

関数型のコードはSN比が高い（S/N比・・・信号に対するノイズ(雑音)の量を対数で表したもの）<br>
つまり、記述するコードは少ないが多くのことを実行する。

これにより実現されること
* バグの原因を回避（状態変更の数が少ないから）
* 容易な並列化
* 表現力が高い？？
* より簡潔？
* 直感的？

いくつか疑念は残る。。。

## 1.3 なぜ関数型で記述するのか
* 1.3.1 強化されたイテレータ<br>
汎用的なイテレータに代わって、様々なタイプの処理に特化したイテレータが提供されている
* 1.3.2 ポリシーの強制<br>
APIによって、ソースコードの記述設計を強制するという話？
* 1.3.3 ポリシーの拡張<br>
拡張可能なポリシーとは？
* 1.3.4 混乱の無いコンカレンシー<br>
ラムダ式を使用すると、シーケンシャルな処理を容易に並列処理に変更できる。
* 1.3.5 物語を語る<br>
適切に実装されたラムダ式は、必要充分な情報が記述されるため、読みやすい。
* 1.3.6 関心の分離<br>
ラムダ式を使用すると、関心の分離も容易。
* 1.3.7 評価を遅らせる<br>
ラムダ式であっても、遅延処理の実装は可能。
* 1.3.8 テスト環境の向上<br>
ラムダ式はテストコードにも活用できる。

## 1.4 革命ではなく、進化

* 1.4.1 宣言的になる<br>
低レベルの命令を使用する手法ではなくの宣言型の手法を。
* 1.4.2 不変性を尊重する<br>
可能な限り、finalや不変オブジェクトを使う。
* 1.4.3 副作用を避ける<br>
副作用を避けることで、並行処理を簡単に使えるようになる。
* 1.4.4 文より式を優先する<br>
for文よりsum()メソッド、など。
* 1.4.5 高階関数を使って設計する<br>
 ・関数を関数に渡す<br>
 ・関数内で関数を生成する<br>
 ・関数から関数を返す

# 1.5 簡単にするためほんの少しの砂糖



# 1.6 まとめ


